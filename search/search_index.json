{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>Welcome to the Forest City Labs Framework documentation. The FCL Framework is a collection of components that adhere to PHP Standards Recommendations wherever possible, creating implementation-agnostic tools that are commonly needed or used within frameworks. The framework specifically targets web applications that function primarily as graphql apis, however, there are many use cases beyond that.</p>"},{"location":"#standard-install","title":"Standard Install","text":"<p>If you are not interested in how the individual components work and instead want to jump right into building and using a graphql api please check out the standard install repository. This repository chooses sane implementations of all required interfaces and configures them in a way that will suit most use-cases. The documentation for this repository will focus on providing your own implementations.</p>"},{"location":"components/caching/","title":"Caching","text":"<p>The Forest City Labs Framework ships with several implementations of the PSR-6 for a few common caching back-ends. There are also several commands that can be used to manage the cache backends.</p>"},{"location":"components/caching/#drivers","title":"Drivers","text":""},{"location":"components/caching/#filesystemcachepool","title":"<code>FilesystemCachePool</code>","text":""},{"location":"components/caching/#requirements","title":"Requirements","text":"<ul> <li>league/flysystem:^3.0</li> </ul>"},{"location":"components/caching/#configuration","title":"Configuration","text":"<p>The filesystem cache pool accepts a flysystem and uses that to serialize and store cache items.</p> <pre><code>&lt;?php\n\nuse ForestCityLabs\\Framework\\Cache\\Pool\\FilesystemCachePool;\nuse League\\Flysystem\\Flysystem;\nuse League\\Flysystem\\Local\\LocalFilesystemAdapter;\n\n$pool = new FilesystemCachePool(\n    new Flysystem(\n        new LocalFilesystemAdapter(__DIR__ . '/var/cache')\n    )\n)\n</code></pre>"},{"location":"components/caching/#dbalcachepool","title":"<code>DbalCachePool</code>","text":""},{"location":"components/caching/#requirements_1","title":"Requirements","text":"<ul> <li>doctrine/dbal:^3.0</li> </ul>"},{"location":"components/caching/#configuration_1","title":"Configuration","text":"<pre><code>&lt;?php\n\nuse Doctrine\\DBAL\\DriverManager;\nuse Doctrine\\DBAL\\Tools\\DsnParser;\nuse ForestCityLabs\\Framework\\Cache\\Pool\\DbalCachePool;\n\n$connection = DriverManager::getConnection(\n    (new DsnParser())-&gt;parse('mysqli://root:root@localhost/app')\n); \n$pool = new DbalCachePool($connection);\n</code></pre>"},{"location":"components/caching/#prediscachepool","title":"<code>PredisCachePool</code>","text":""},{"location":"components/caching/#requirements_2","title":"Requirements","text":"<ul> <li>predis/predis:^2.0</li> </ul>"},{"location":"components/caching/#configuration_2","title":"Configuration","text":"<pre><code>&lt;?php\n\nuse ForestCityLabs\\Framework\\Cache\\Pool\\PredisCachePool;\nuse Predis\\Client;\n\n$pool = new PredisCachePool(new Client());\n</code></pre>"},{"location":"components/class_discovery/","title":"Class Discovery","text":"<p>There are many situations where a component may need to parse a list of classes for attributes, getting this list of classes can be done using the class discovery component.</p>"},{"location":"components/class_discovery/#scan-directory-class-discovery","title":"Scan Directory Class Discovery","text":"<p>The scan directory class discovery component allows you to define paths to directories and returns a list of classes found in those directories.</p> <pre><code>&lt;?php\n\nuse ForestCityLabs\\Framework\\Utility\\ClassDiscovery\\ScanDirectoryDiscovery;\n\n$discovery = new ScanDirectoryDiscovery([__DIR__ . '/src/Entity']);\n$classes = $discovery-&gt;discoverClasses();\n</code></pre> <p>The above example will return all classes defined in the <code>src/Entity</code> directory.</p>"},{"location":"components/class_discovery/#manual-class-discovery","title":"Manual Class Discovery","text":"<p>The simplest way to define classes is to just tell the system which classes you are looking for.</p> <pre><code>&lt;?php\n\nuse ForestCityLabs\\Framework\\Utility\\ClassDiscovery\\ManualDiscovery;\n\n$discovery = new ManualDiscovery([\\DateTimeInterface::class]);\n$classes = $discover-&gt;discoverClasses();\n</code></pre>"},{"location":"components/class_discovery/#chained-class-discovery","title":"Chained Class Discovery","text":"<p>The above methods can be combined using the chained class discovery method.</p> <pre><code>&lt;?php\n\nuse ForestCityLabs\\Framework\\Utility\\ClassDiscovery\\ChainedDiscovery;\nuse ForestCityLabs\\Framework\\Utility\\ClassDiscovery\\ScanDirectoryDiscovery;\nuse ForestCityLabs\\Framework\\Utility\\ClassDiscovery\\ManualDiscovery;\n\n$discovery = new ChainedDiscovery([\n    new ManualDiscovery([\\DateTimeInterface::class]),\n    new ScanDirectoryDiscovery([__DIR__ . 'src/Entity']),\n]);\n$classes = $discovery-&gt;discoverClasses();\n</code></pre>"},{"location":"components/events/","title":"Events","text":"<p>The Forest City Labs Framework ships with a generic ListenerProvider that can be used in conjunction with any PSR-14 compliant event dispatcher (for example league/event).</p> <p>To configure an event listener you can use the <code>ForestCityLabs\\Event\\Attribute\\EventListener</code> attribute.</p>"},{"location":"components/events/#creating-an-event-listener","title":"Creating an Event Listener","text":"<pre><code>&lt;?php\n\nnamespace Application\\EventListener;\n\nuse ForestCityLabs\\Framework\\Attribute\\EventListener;\nuse ForestCityLabs\\Framework\\Event\\ListenerProvider;\nuse ForestCityLabs\\Framework\\Events\\PreRouteDispatchEvent;\n\n#[EventListener(PreRouteDispatchEvent::class, priority: ListenerProvider::PRIORITY_LATE)]\nclass PreRouteDispatchEventListener\n{\n    public function __invoke(PreRouteDispatchEvent $event) \n    {\n        // ...do something with the event.\n    }\n}\n</code></pre> <p>The above example will listen for the pre route dispatch event and act later than most other events.</p> <p>Note</p> <p>The available priorities for the listener are, in order:</p> <ul> <li><code>PRIORITY_FIRST</code></li> <li><code>PRIORITY_EARLY</code></li> <li><code>PRIORITY_NORMAL</code></li> <li><code>PRIORITY_LATE</code></li> <li><code>PRIORITY_LAST</code></li> </ul> <p>Please note that there is no guarantee that first or last will be first or last, just earlier/later than events using the other constants.</p>"},{"location":"components/events/#configuring-an-event-dispatcher","title":"Configuring an Event Dispatcher","text":"<p>To create an event dispatcher you first need to configure our listener provider.</p> <p>Warning</p> <p>The example below uses the league event dispatcher, other event systems should work in a similar way, but there is no standard for how to wire a listener provider to a dispatcher.</p> <pre><code>&lt;?php\n\nuse ForestCityLabs\\Framework\\Event\\ListenerProvider;\nuse ForestCityLabs\\Framework\\Utility\\ClassDiscovery\\ScanDirectoryDiscovery;\nuse League\\Event\\EventDispatcher;\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Cache\\CacheItemPoolInterface;\n\n$provider = new ListenerProvider(\n    new ScanDirectoryDiscovery(__DIR__ . '/src/EventListener'),\n    new CacheItemPoolInterface(), // Must be a concrete implementation.\n    new ContainerInterface(), // Must be a concrete implementation.\n);\n\n// Now we can create the dispatcher.\n$dispatcher = new EventDispatcher($provider);\n\n// Dispatch an event.\n$dispatcher-&gt;dispatch(new PreRouteDispatchEvent());\n</code></pre> <p>Tip</p> <p>To learn more about the <code>ScanDirectoryDiscovery</code> class and class discovery in general take a look at the class discovery documentation.</p>"},{"location":"components/routing/","title":"Routing","text":"<p>The routing component consists of PSR-15 middleware that uses the nikic/fast-route package to route requests at specific paths to controllers.</p> <p>Route mappings are defined using PHP Attributes on their relevant controllers.</p>"},{"location":"components/routing/#requirements","title":"Requirements","text":"<ul> <li>nikic/fast-route</li> <li>cocur/slugify</li> <li>A container library implementing PSR-11.</li> <li>An event dispatcher library implementing PSR-14.</li> <li>A response factory library implementing PSR-17.</li> <li>A cache library implementing PSR-6 (check the caching section for implementations that this framework provides).</li> <li>A logging library implementing PSR-3.</li> <li>A PSR-15 compliant request handler (see the Kernel class for a request handler that ships with this framework).</li> </ul>"},{"location":"components/routing/#usage","title":"Usage","text":""},{"location":"components/routing/#creating-controllers","title":"Creating controllers","text":"<p>Controllers are any class that uses attributes to map methods to paths. PHP attributes are used to create this relationship. Every method must return an object implementing the <code>Psr\\Http\\Message\\ResponseInterface</code> interface.</p> Example controller<pre><code>use ForestCityLabs\\Framework\\Routing\\Attribute\\Route;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass MyController\n{\n    #[Route(\"/home\")]\n    public function home(): ResponseInterface\n    {\n        return new Response();\n    }\n}\n</code></pre>"},{"location":"components/routing/#controllers-are-services","title":"Controllers are services","text":"<p>All controllers are considered services in the FCL Framework, so making use of other services is done through the use of wiring them into the constructor using your preferred PSR-11 compliant container. Here is an example of using a response factory to create a response instead of creating the response manually.</p> Example service use in a controller<pre><code>use ForestCityLabs\\Framework\\Routing\\Attribute\\Route;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\n\nclass MyController\n{\n    public function __construct(\n        private ResponseFactoryInterface $response_factory\n    ) {}\n\n    #[Route(\"/home\")]\n    public function home(): ResponseInterface\n    {\n        return $this-&gt;response_factory-&gt;createResponse();\n    }\n}\n</code></pre> <p>If your service is not required in every method of the controller you may with to only inject the service into the specific method, which can be done the by type-hinting the service in the method.</p> Using a service in a single method<pre><code>use ForestCityLabs\\Framework\\Routing\\Attribute\\Route;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\n\nclass MyController\n{\n    #[Route(\"/home\")]\n    public function home(\n        ResponseFactoryInterface $response_factory\n    ): ResponseInterface {\n        return $response_factory-&gt;createResponse();\n    }\n}\n</code></pre>"},{"location":"components/routing/#accessing-the-incoming-request","title":"Accessing the incoming request","text":"<p>A common requirement within a controller is accessing the incoming request, this can be done by simply adding the request as a parameter on the method as shown.</p> Accessing the incoming request<pre><code>use ForestCityLabs\\Framework\\Routing\\Attribute\\Route;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass MyController\n{\n    #[Route(\"/home\")]\n    public function home(ServerRequestInterface $request): ResponseInterface\n    {\n        $auth_token = $request-&gt;getHeader('token');\n        return new Response();\n    }\n}\n</code></pre>"},{"location":"components/routing/#using-path-parameters","title":"Using path parameters","text":"<p>You can use path parameters as defined in nikic/FastRoute, here is an example of mapping a parameter into the method.</p> Parameters in paths<pre><code>use ForestCityLabs\\Framework\\Routing\\Attribute\\Route;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass MyController\n{\n    #[Route(\"/blog/{id}\")]\n    public function getBlog(string $id): ResponseInterface\n    {\n        return new Response();\n    }\n}\n</code></pre>"},{"location":"components/routing/#using-the-middleware","title":"Using the Middleware","text":"<p>The middleware requires the metadata provider to be able to match a path to the controller. To create the middleware you need to pass this in as well.</p> Middleware usage example<pre><code>use ForestCityLabs\\Framework\\Routing\\MetadataProvider;\nuse ForestCityLabs\\Framework\\Utility\\ClassDiscovery\\ManualClassDiscovery;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Cache\\CacheItemPoolInterface;\nuse Cocur\\Slugify\\Slugify;\n\n$metadata_provider = new MetadataProvider(\n    new ManualDiscovery([\\Application\\Controller\\MyController::class]), # (1)\n    new CacheItemPoolInterface(), # (2)\n    new LoggerInterface(), # (3)\n    new Slugify()\n);\n\n$middleware = new RoutingMiddleware(\n    $container, # (4)\n    $route_dispatcher, # (5)\n    $event_dispatcher, # (6)\n    $metadata_provider,\n    $response_factory, # (7)\n    $parameter_processor # (8)\n);\n\n$kernel-&gt;addMiddleware($middleware);\n</code></pre> <ol> <li>This is an array of classes that are annotated with your routing metadata.</li> <li>A PSR-6 compliant cache pool.</li> <li>A PSR-3 compliant logger.</li> <li>A PSR-11 compliant container.</li> <li>The route dispatcher to use when matching routes.</li> <li>A PSR-14 compliant event dispatcher.</li> <li>A PSR-17 compliant http response factory.</li> <li>The parameter processor service.</li> </ol>"},{"location":"components/sessions/","title":"Sessions","text":"<p>The Forest City Labs Framework uses a custom sessions implementation that is both object-oriented and fits in the middleware paradigm.</p>"},{"location":"components/sessions/#requirements","title":"Requirements","text":"<p>The session component requires the <code>dflydev/fig-cookies</code> library to function.</p> <p>The session drivers must have a back-end, the available drivers are:</p> <ul> <li>Filesystem: league/flysystem:^3.0</li> <li>DBAL: doctrine/dbal:^3.0</li> <li>Predis: predis/predis:^2.0</li> </ul>"},{"location":"components/sessions/#configuration","title":"Configuration","text":""},{"location":"components/sessions/#available-drivers","title":"Available Drivers","text":""},{"location":"components/sessions/#filesystem","title":"Filesystem","text":"<p>To configure the filesystem driver simply create a flysystem using any adapter and pass it to the session driver as follows.</p> Filesystem Session Driver<pre><code>&lt;?php\n\nuse League\\Flysystem\\Filesystem;\nuse League\\Flysystem\\Local\\LocalFilesystemAdapter;\nuse ForestCityLabs\\Framework\\Session\\Driver\\FilesystemSessionDriver;\n\n$driver = new FilesystemSessionDriver(\n    new Filesystem(\n        new LocalFilesystemAdapter(__DIR__ . '/var/session')\n    )\n);\n</code></pre>"},{"location":"components/sessions/#dbal","title":"DBAL","text":"<p>To use the DBAL adapter you also need to create the session table within the corresponding database. The <code>session:create-table</code> command can be used for this purpose.</p> DBAL Session Driver<pre><code>&lt;?php\n\nuse Doctrine\\DBAL\\DriverManager;\nuse ForestCityLabs\\Framework\\Session\\Driver\\DbalSessionDriver;\n\n$driver = new DbalSessionDriver(\n    DriverManager::getConnection([\n        'dbname' =&gt; 'mydb',\n        'user' =&gt; 'user',\n        'password' =&gt; 'secret',\n        'host' =&gt; 'localhost',\n        'driver' =&gt; 'pdo_mysql',\n    ])\n);\n</code></pre> <p>Note</p> <p>You can set the table name using the second parameter in the constructor, the default is <code>session</code>.</p>"},{"location":"components/sessions/#predis","title":"Predis","text":"<p>The predis adapter only requires a predis client to function, you can create one as follows.</p> Predis Session Driver<pre><code>&lt;?php\n\nuse ForestCityLabs\\Framework\\Session\\Driver\\PredisSessionDriver;\nuse Predis\\Client;\n\n$driver = new PredisSessionDriver(\n    new Client()\n);\n</code></pre>"},{"location":"components/sessions/#usage","title":"Usage","text":"<p>To use a session you need to create a session and fill it with items, the session middleware will handle much of this for you by creating a <code>_session</code> attribute on your request and checking if that attribute has items within it. This middleware will automatically manage your cookies using the <code>dflydev/fig-cookies</code> library.</p> <pre><code>&lt;?php\n\nuse ForestCityLabs\\Framework\\Middleware\\SessionMiddleware;\n\n$middleware = new SessionMiddleware($driver);\n$kernel-&gt;addMiddleware($middleware);\n$kernel-&gt;handle($request);\n</code></pre> <p>The <code>ForestCityLabs\\Framework\\Session\\Session</code> class is the API for interacting with the session.</p> <pre><code>&lt;?php\n\n$session = $request-&gt;getAttribute('_session');\n$session-&gt;setValue('hello', 'there');\n</code></pre> <p>Once the session reaches the middleware again it will be automatically saved using the configured driver.</p> <pre><code>&lt;?php\n\n$session = $request-&gt;getAttribute('_session');\nprint_r($session-&gt;getValue('hello'));\n/**\n * Will output \"there\".\n */\n</code></pre>"},{"location":"components/graphql/mapping/enum_types/","title":"Enum Types","text":""},{"location":"components/graphql/mapping/enum_types/#definition","title":"Definition","text":"<p>Enum types are defined as PHP enums.</p> <p>src/Entity/AppleTypeEnum.php<pre><code>&lt;?php\n\nnamespace Application\\Entity;\n\nuse ForestCityLabs\\Framework\\GraphQL\\Attribute as GraphQL;\n\n#[GraphQL\\EnumType]\nenum AppleTypeEnum\n{\n    #[GraphQL\\Value]\n    case MACINTOSH;\n\n    #[GraphQL\\Value]\n    case GREEN_DELICIOUS;\n\n    #[GraphQL\\Value]\n    case ROYAL_GALA;\n}\n</code></pre> Would result in the following schema:</p> <pre><code>enum AppleTypeEnum {\n    MACINTOSH\n    GREEN_DELICIOUS\n    ROYAL_GALA\n}\n</code></pre>"},{"location":"components/graphql/mapping/enum_types/#usage","title":"Usage","text":"<p>Enums are unique as they can be used as both fields (output) and arguments (input), so when a return type or argument type is set to a mapped php enum it will be mapped in the schema as such.</p>"},{"location":"components/graphql/mapping/enum_types/#field-example","title":"Field Example","text":"src/Entity/Apple.php<pre><code>&lt;?php\n\nnamespace Application\\Entity;\n\nuse ForestCityLabs\\Framework\\GraphQL\\Attribute as GraphQL;\n\n#[GraphQL\\ObjectType]\nclass Apple\n{\n    #[GraphQL\\Field]\n    private UuidInterface $id;\n\n    #[GraphQL\\Field]\n    private AppleTypeEnum $type;\n}\n</code></pre> <pre><code>type Apple {\n    id: ID!\n    type: AppleTypeEnum!\n}\n</code></pre>"},{"location":"components/graphql/mapping/enum_types/#argument-example","title":"Argument Example","text":"src/Controller/AppleController.php<pre><code>&lt;?php\n\nnamespace Application\\Controller;\n\nuse ForestCityLabs\\Framework\\GraphQL\\Attribute as GraphQL;\n\nclass AppleController\n{\n    #[GraphQL\\Query]\n    #[GraphQL\\Field(type: \"Apple\")]\n    public function getApplesByType(\n        #[GraphQL\\Argument] AppleTypeEnum $type\n    ): array {\n        // ...do some logic based on the apple type enum.\n        return [];\n    }\n}\n</code></pre> <pre><code>type Query {\n    getApplesByType(type: AppleTypeEnum!): [Apple!]!\n}\n</code></pre>"},{"location":"components/graphql/mapping/input_types/","title":"Input Types","text":""},{"location":"components/graphql/mapping/input_types/#definition","title":"Definition","text":"<p>Input types can easily be defined on top of object types by defining arguments on the same properties as fields.</p> <pre><code>&lt;?php\n\nnamespace Application\\Entity;\n\nuse ForestCityLabs\\Framework\\GraphQL\\Attribute as GraphQL;\n\n#[GraphQL\\ObjectType]\n#[GraphQL\\InputType(name: \"AppleInput\")]\nclass Apple\n{\n    #[GraphQL\\Field]\n    private UuidInterface $uuid;\n\n    #[GraphQL\\Field]\n    #[GraphQL\\Argument]\n    private string $type;\n\n    #[GraphQL\\Field]\n    #[GraphQL\\Argument]\n    private ?string $name;\n}\n</code></pre> <p>Note</p> <p>If you do not set a custom <code>name</code> attribute for the input type in the above example it will select \"Apple\" by default and override the \"Apple\" object type.</p> <p>Our schema for apples then becomes:</p> <pre><code>type Apple {\n    uuid: ID!\n    type: String!\n    name: String\n}\n\ninput AppleInput {\n    type: String!\n    name: String\n}\n</code></pre>"},{"location":"components/graphql/mapping/input_types/#usage","title":"Usage","text":"<p>Input types can be used in controllers (and nested within one another). Values passed to the API endpoint will be automatically transformed to their representative class before being passed into the controller method, for example:</p> src/Entity/AppleController.php<pre><code>&lt;?php\n\nnamespace Application\\Controller;\n\nuse ForestCityLabs\\Framework\\GraphQL\\Attribute as GraphQL;\n\nclass AppleController\n{\n    #[GraphQL\\Mutation]\n    #[GraphQL\\Field]\n    public function addApple(\n        #[GraphQL\\Argument] Apple $apple\n    ): Apple {\n        // ...do something to persist the apple.\n        return $apple;\n    }\n}\n</code></pre> <pre><code>type Mutation {\n    addApple(apple: AppleInput!): Apple\n}\n</code></pre>"},{"location":"components/graphql/mapping/interface_types/","title":"Interface Types","text":"<p>Interface types are defined natively using php interfaces, abstract classes or classes. Once defined you simply need to define an object type that extends that interface and it will be mapped automatically.</p> src/Entity/FruitInterface.php<pre><code>&lt;?php\n\nnamespace Application\\Entity;\n\nuse ForestCityLabs\\Framework\\GraphQL\\Attribute as GraphQL;\n\n#[GraphQL\\InterfaceType]\ninterface FruitInterface\n{\n    #[GraphQL\\Field(name: 'region')]\n    public function getRegion(): string;\n}\n</code></pre> src/Entity/Apple.php<pre><code>&lt;?php\n\nnamespace Application\\Entity;\n\nuse ForestCityLabs\\Framework\\GraphQL\\Attribute as GraphQL;\n\n#[GraphQL\\ObjectType]\nclass Apple implements FruitInterface\n{\n    #[GraphQL\\Field]\n    private UuidInterface $uuid;\n\n    #[GraphQL\\Field]\n    private string $region;\n\n    public function getRegion(): string\n    {\n        return $this-&gt;region;\n    }\n}\n</code></pre> <p>These definitions would result in the following schema:</p> schema.graphql<pre><code>interface Fruit {\n    region: String!\n}\n\ntype Apple implements Fruit {\n    uuid: ID!\n    region: String!\n}\n</code></pre>"},{"location":"components/graphql/mapping/object_types/","title":"Object Types","text":"<p>Object types are usually the first thing you map in building out your schema. You will typically use entities in your system to construct objects.</p> <pre><code>&lt;?php\n\nnamespace Application\\Entity;\n\nuse ForestCityLabs\\Framework\\GraphQL\\Attribute as GraphQL;\n\n#[GraphQL\\ObjectType]\nclass Apple\n{\n    #[GraphQL\\Field]\n    private UuidInterface $uuid;\n\n    #[GraphQL\\Field]\n    private string $type;\n\n    #[GraphQL\\Field]\n    private ?string $name;\n}\n</code></pre> <p>Note</p> <p>You can set custom properties like <code>name</code>, <code>description</code>, <code>type</code>, <code>list</code>, <code>not_null</code> and <code>deprecation_reason</code> on attributes, but reasonable defaults will be chosen if you do not do this.</p> <p>The above entity would be represented as such in your schema:</p> <pre><code>type Apple {\n    uuid: ID!\n    type: String!\n    name: String\n}\n</code></pre>"},{"location":"components/graphql/mapping/object_types/#annotations","title":"Annotations","text":"<p>Let's take a moment to analyze the attributes we used to define our schema above.</p>"},{"location":"components/graphql/mapping/object_types/#objecttype","title":"<code>ObjectType</code>","text":"<p>The object type annotation tells our schema that this is a custom object type. You can define a custom name, if none is provided then it will use the class name (\"Apple\" in this case). You can also provide a description that will help users of the API understand your type.</p>"},{"location":"components/graphql/mapping/object_types/#field","title":"<code>Field</code>","text":"<p>The field attribute allows you to define fields on your custom type. Reasonable defaults will be selected for <code>name</code>, <code>type</code>, <code>list</code> and <code>not_null</code> if possible.</p>"},{"location":"components/graphql/reference/attribute_reference/","title":"Attribute Reference","text":"<p>The following attributes can be used to map your types and controllers.</p>"},{"location":"components/graphql/reference/attribute_reference/#objecttype","title":"ObjectType","text":"<p>Targets: Classes</p> <p>Parameters:</p> <ul> <li>name (optional): The name of the object type in the schema, defaults to the class name.</li> <li>description (optional): The description of the object type in the schema, defaults to null.</li> </ul>"},{"location":"components/graphql/reference/attribute_reference/#inputtype","title":"InputType","text":"<p>Targets: Classes</p> <p>Parameters:</p> <ul> <li>name (optional): The name of the input type in the schema, defaults to the class name.</li> <li>description (optional): The description of the input type in the schema, defaults to null.</li> </ul>"},{"location":"components/graphql/reference/attribute_reference/#interfacetype","title":"InterfaceType","text":"<p>Targets: Classes</p> <p>Parameters:</p> <ul> <li>name (optional): The name of the interface type in the schema, defaults to the class name.</li> <li>description (optional): The description of the interface type in the schema, defaults to null.</li> </ul>"},{"location":"components/graphql/reference/attribute_reference/#enumtype","title":"EnumType","text":"<p>Targets: Classes</p> <p>Parameters:</p> <ul> <li>name (optional): The name of the enum type in the schema, defaults to the class name.</li> <li>description (optional): The description of the enum type in the schema, defaults to null.</li> </ul>"},{"location":"components/graphql/reference/attribute_reference/#field","title":"Field","text":"<p>Targets: Class methods and properties</p> <p>Parameters:</p> <ul> <li>name (optional): The name of the field in the schema, defaults to the property or method name.</li> <li>description (optional): The description of the field in the schema, defaults to null.</li> <li>list (optional): Whether this will return a list or not, will default to true if the type of the property or method is iterable.</li> <li>type (optional): The type for this field, will attempt to detect a default from the return type, automapping custom object types if possible.</li> <li>not_null (optional): Whether this is optional or not, will use the return type to determine a value if not set explicitly.</li> <li>deprecation_reason (optional): The deprecation reason for this field.</li> </ul>"},{"location":"utilities/parameter_converters/","title":"Parameter Converters","text":"<p>The primary responsibility of a parameter converter is to examine a function (or class method) and a list of passed arguments, converting arguments from one representation to another.</p> <p>A good example is dates, you might want to accept dates as part of a URL pattern and convert the to a real <code>\\DateTime</code> object before passing them to your controller.</p> <p>Note</p> <p>This framework ships with several converters, however, it is trivial to make your own using the <code>ParameterConverterInterface</code>.</p>"},{"location":"utilities/parameter_resolvers/","title":"Parameter Resolvers","text":"<p>The primary purpose of parameter resolvers is to examine a function or class method using reflection and return an array of arguments (keyed by parameter name).</p> <p>Note</p> <p>Several resolvers ship with the framework, however, making your own is trivial using the <code>ParameterResolverInterface</code>.</p> <p>The goal of a parameter resolver is to fill in missing parameters, not convert them to another representation, to do that please take a look at parameter converters.</p>"}]}